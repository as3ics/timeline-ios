//
//  Entry.swift
//  Timeline Software, LLC
//
//  Created by Timeline Software, LLC on 3/8/16.
//  Copyright Â© 2016 Timeline Software, LLC. All rights reserved.
//

import Foundation
import MapKit
import CoreLocation
import Material
import CoreData

// MARK: - Entries

@objcMembers class Entries: APIContainer<Entry> {

    // MARK: - Descriptors
    
    override var modelType: ModelType {
        return ModelType.Entries
    }
    
    override var descriptor: String {
        return "Entries"
    }
    
    // MARK: - Initializers
    
    init(sheet: Sheet?) {
        self.sheet = sheet
    }
    
    // MARK: - Other Properties
    
    weak var sheet: Sheet?
    var loaded: Bool = false

    var latest: Entry? {
        return items.first
    }

    var earliest: Entry? {
        return items.last
    }

    override func sort() {
        items.sort(by: { $1.start!.timeIntervalSince1970 < $0.start!.timeIntervalSince1970 })
    }
    
    func sortReverse() {
        items.sort(by: { $1.start!.timeIntervalSince1970 > $0.start!.timeIntervalSince1970 })
    }

    var hasEntries: Bool {
        return count > 0
    }
    
    // MARK: - API Protocol Constructors
    
    override var retrieveUrl: String? {
        guard let orgId = Auth.shared.orgId, let timesheetId = self.sheet?.id else {
            return nil
        }
        
        return String(format: "/organizations/%@/timesheets/%@/entries", arguments: [orgId, timesheetId])
    }
    
    override var retrieveParams: JSON? {
        return EMPTY_JSON
    }
    
    override func process(_ callback: @escaping (_ err: Error?, _ newResult: Any?) -> Void, _ initialValue: Any?) {
        
        guard let data = initialValue as? [JSON] else {
            callback(nil, nil)
            return
        }
        
        items.removeAll()
        
        for value in data {
            let item = Item(attrs: value)
            item.breadcrumbs.entry = item.id
            item.breadcrumbs.sheet = sheet?.id
            item.sheet = sheet
            items.append(item)
        }
        
        self.sort()
        
        guard items.count > 0 else {
            self.loaded = true
            callback(nil, nil)
            return
        }
        
        for (index, item) in items.enumerated() {
            Async.waterfall(nil, [item.breadcrumbs.retrieve, item.retrievePhotos], end: { _, _ in
                if index >= self.items.count - 1 {
                    self.loaded = true
                    callback(nil, nil)
                }
            })
        }
    }
    
    func clearAnnotations() {
        for entry in self.items {
            entry.annotation = nil
        }
    }
}

@objcMembers class Entry: APIModel, RegionProtocol {

    override var descriptor: String {
        return "Entry"
    }
    
    override var modelType: ModelType {
        return ModelType.Entry
    }
    
    override var keys: [String] {
        return [ "id", "timestamp", "start", "notes",  "billableTime", "billableMileage", "autoGenerated", "userEdited", "paidTime" ]
    }

    var start: Date?
    var notes: String?
    
    var billableTime: Bool = true
    var billableMileage: Bool = true
    var autoGenerated: Bool = false
    var userEdited: Bool = false
    var paidTime: Bool = true

    var seconds: Double! = 0.0
    var meters: Double! = 0.0

    var sheet: Sheet?
    var location: Location?
    var user: User?
    var activity: Activity?

    var breadcrumbs: Breadcrumbs = Breadcrumbs()

    var snapshot: UIImage?
    var annotation: MKAnnotation?
    var clusterIndex: Int = -1
    var overlayColor: UIColor?
    
    required init() {
        super.init()
    }

    required init(attrs: JSON) {
        super.init(attrs: attrs)

        if let seconds = attrs["seconds"]?.doubleValue { self.seconds = seconds }
        if let meters = attrs["meters"]?.doubleValue { self.meters = meters }

        if self.sheet == nil, let sheetAttrs = attrs["sheet"] as? JSON, let sheetId = sheetAttrs["id"] as? String {
            if sheetId == DeviceUser.shared.sheet?.id {
                self.sheet = DeviceUser.shared.sheet
            } else {
                // foo
            }
        } else if let sheetId = attrs["sheet"] as? String {
            if sheetId == DeviceUser.shared.sheet?.id {
                self.sheet = DeviceUser.shared.sheet
            } else {
                // foo
            }
        }
        
        if let user = attrs["user"] as? JSON, let userId = user["id"] as? String {
            if userId == Auth.shared.id {
                self.user = DeviceUser.shared.user
            } else {
                self.user = Users.shared[userId] ?? User(attrs: user)
            }
        } else if let userId = attrs["user"] as? String {
            if userId == Auth.shared.id {
                self.user = DeviceUser.shared.user
            } else {
                self.user = Users.shared[userId]
            }
        }
        
        if let activity = attrs["activity"] as? JSON, let activityId = activity["id"] as? String {
            self.activity = Activities.shared[activityId]// ?? Activity(attrs: activity)
        } else if let activityId = attrs["activity"] as? String {
             self.activity = Activities.shared[activityId]
        }
        
        if let locationAttrs = attrs["location"] as? JSON, let locationId = locationAttrs["id"] as? String {
            self.location = Locations.shared[locationId]// ?? Location(attrs: locationAttrs)
        } else if let locationId = attrs["location"] as? String {
            self.location = Locations.shared[locationId]
        }
    }

    required public init(object: NSManagedObject) {
        super.init(object: object)
        
    }
    
    override var createUrl: String? {
        guard let orgId = Auth.shared.orgId, let timesheetId = self.sheet?.id else {
            return nil
        }
        
        return String(format: "/organizations/%@/timesheets/%@/entries", arguments: [orgId, timesheetId])
    }
    
    override var createParams: JSON? {
        guard let userId = self.user?.id ?? Auth.shared.id, let activityId = self.activity?.id, let createdBy = Auth.shared.id else {
            return nil
        }
        
        let date = self.start ?? Date()
        
        var params: JSON = [
            "activity" : activityId as JSONObject,
            "user" : userId as JSONObject,
            "start" : APIClient.shared.formatter.string(from: date) as JSONObject,
            "paidTime" : paidTime as JSONObject,
            "autoGenerated": autoGenerated as JSONObject,
            "createdBy": createdBy as JSONObject
        ]
        
        if let locationId = self.location?.id {
            params["location"] = locationId as JSONObject
        }
        
        return params
    }
    
    override func processCreate(data: JSON) -> Bool {
        guard let id = data["id"] as? String else {
            return false
        }
        
        self.id = id
        
        return true
    }
    
    override var retrieveUrl: String? {
        guard let orgId = Auth.shared.orgId, let sheetId = self.sheet?.id, let entryId = self.id else {
            return nil
        }
        
        return String(format: "/organizations/%@/timesheets/%@/entries/%@", arguments: [orgId, sheetId, entryId])
    }
    
    override var retrieveParams: JSON? {
        return EMPTY_JSON
    }
    
    override func processRetrieve(data: JSON) -> JSON? {
        let entry = Entry(attrs: data)
        
        let container: JSON = [
            "model": entry as JSONObject,
            ]
        
        return container
    }

    override var updateUrl: String? {
        guard let orgId = Auth.shared.orgId, let sheetId = self.sheet?.id, let entryId = self.id else {
            return nil
        }
        
        return String(format: "/organizations/%@/timesheets/%@/entries/%@", arguments: [orgId, sheetId, entryId])
    }
    
    override var updateParams: JSON? {
        guard let updatedBy = Auth.shared.id else {
            return nil
        }
        
        self.userEdited = true
        
        var params: JSON = toJson()
        params["updatedBy"] = updatedBy as JSONObject
        return params
    }

    override var deleteUrl: String? {
        guard let orgId = Auth.shared.orgId, let timesheetId = self.sheet?.id, let entryId = self.id else {
            return nil
        }
        
        return String(format: "/organizations/%@/timesheets/%@/entries/%@?hard=true", arguments: [orgId, timesheetId, entryId])
    }
    
    override var deleteParams: JSON? {
        return EMPTY_JSON
    }

    var region: MKCoordinateRegion? {
        get {
            var region: MKCoordinateRegion?

            if activity?.breaking == true {
                region = nil
            } else if breadcrumbs.count > 0 {
                region = breadcrumbs.region
            } else if let location = self.location {
                region = location.region
            } else {
                region = sheet?.region
            }

            return region
        }
        set {
        }
    }
    
    override func cleanse() {
        super.cleanse()
        
        self.breadcrumbs.items.removeAll()
    }

    override func toJson() -> JSON {
        var json = self.json()
        
        if let sheet = self.sheet?.id { json["sheet"] = sheet as JSONObject }
        if let location = self.location?.id { json["location"] = location as JSONObject }
        if let user = self.user?.id { json["user"] = user as JSONObject }
        if let activity = self.activity?.id { json["activity"] = activity as JSONObject }
        if let meters = self.meters { json["meters"] = "\(meters)" as JSONObject }
        if let seconds = self.seconds { json["seconds"] = "\(seconds)" as JSONObject }

        return json
    }
}

extension Entry {

    var hours: Double {
        return floor((seconds ?? 0.0) / 3600.0)
    }

    var mins: Double {
        let remainder = (seconds ?? 0.0).truncatingRemainder(dividingBy: 3600.0)
        return floor(remainder / 60.0)
    }

    var secs: Double {
        return floor((seconds ?? 0.0) / 60.0)
    }

    var startString: String? {
        var value: String?

        if let date = self.start {
            let formatter = DateFormatter()
            formatter.dateFormat = "h:mm a"
            value = formatter.string(from: date as Date)
        }

        return value
    }
}
